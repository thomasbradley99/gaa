# GAA Webapp Data Contract

**Version:** 2.0  
**Last Updated:** November 19, 2025  
**Status:** ‚úÖ PRODUCTION (reflects current implementation after Nov 19 fixes)  
**Purpose:** Define the exact data structures used across Lambda ‚Üí Backend ‚Üí Frontend

---

## üìä Complete Game Object

This is what the frontend expects when fetching `/api/games/:id`

```typescript
{
  // ===== REQUIRED FIELDS =====
  id: string                    // UUID
  title: string                 // "Kilmeena vs Cill Chomain" 
  team_id: string              // UUID - which team uploaded this
  team_name: string            // "Kerry GAA" - from JOIN with teams table
  status: string               // 'pending' | 'downloaded' | 'processing' | 'analyzed' | 'failed'
  created_at: string           // ISO timestamp
  updated_at: string           // ISO timestamp
  
  // ===== VIDEO FIELDS =====
  video_url: string            // Presigned S3 URL or VEO proxy URL
  s3_key?: string              // "videos/{game_id}/video.mp4"
  hls_url?: string             // HLS manifest URL (if transcoded)
  thumbnail_key?: string       // "videos/{game_id}/thumbnail.jpg"
  duration?: number            // Video duration in seconds
  
  // ===== EVENTS (JSONB ARRAY) ===== 
  // ‚úÖ IMPORTANT: This is now a DIRECT ARRAY (not nested object)
  // ‚úÖ SCHEMA: See shared/EVENT_SCHEMA.ts for master definition
  events: Array<{
    id: string               // "event_001"
    time: number             // 311 (seconds from VIDEO START at 0:00, NOT match start)
    team: string             // "home" | "away"
    action: string           // "Shot" | "Kickout" | "Turnover" | "Throw-up" | "Foul"
    outcome: string          // "Point" | "Goal" | "Wide" | "Won" | "Lost" | "N/A"
    
    metadata?: {
      // Event-specific metadata
      scoreType?: string     // "point" | "goal" | "wide" | "saved" | "short_keeper"
      from?: string          // "play" | "free" | "45m"
      kickoutType?: string   // "long" | "short" | "mid" | "void"
      turnoverType?: string  // "forced" | "unforced"
      zone?: string          // "D1" | "M2" | "A3" etc.
      scorable?: boolean     // For fouls
      left?: boolean         // Kickout direction
      right?: boolean        
      centre?: boolean
      
      // Validation flags
      autoGenerated?: boolean // true
      validated?: boolean     // false
      userEdited?: boolean    // false
      editedAt?: string      // ISO timestamp
      
      // Display overrides (set by user in edit mode)
      player?: string        // Player name
      description?: string   // Custom description
      beforePadding?: number // 0-15 seconds
      afterPadding?: number  // 0-15 seconds
    }
  }>,
  
  // ===== METADATA (JSONB) - üî¥ CRITICAL FOR DISPLAY =====
  metadata?: {
    // Team information (detected by AI)
    teams?: {
      home_team: {
        name: string           // "Home" (parsed from title by Lambda)
        jersey_color: string   // "Black" | "White" | "green" | hex (#016F32)
      },
      away_team: {
        name: string           // "Away"
        jersey_color: string   // "White" | "blue" | etc.
      }
    },
    
    // Match analysis metadata
    match_info?: {
      title: string            // "GAA Match Events"
      total_events: number     // 42
      analysis_method: string  // "Gemini AI - First 10 minutes"
      created_at: string       // ISO timestamp
    },
    
    // Team color mapping (AI-detected ‚Üí home/away)
    team_mapping?: {
      red: "home" | "away"     // Maps AI-detected red team to home or away
      blue: "home" | "away"    // Maps AI-detected blue team to home or away
    },
    
    // Optional analytics metadata
    updated_at?: string            // ISO timestamp
    analysis_duration?: string     // "3m 42s"
    match_start_detected?: number  // 300 (seconds into recording)
    keeper_colors?: {
      home: string                 // "pink"
      away: string                 // "green"  
    },
    attacking_directions?: {
      home: string                 // "left-to-right"
      away: string                 // "right-to-left"
    }
  },
  
  // ===== OTHER FIELDS =====
  description?: string         // User-provided description
  file_type?: string          // "veo" | "upload" | "trace" | "spiideo"
  original_filename?: string   // "match.mp4"
  file_size?: number          // Bytes
  is_demo?: boolean           // true for demo games
  created_by?: string         // User UUID
  uploaded_by?: string        // User UUID
  xml_s3_key?: string         // "videos/{game_id}/analysis.xml"
  tactical_analysis?: object  // Future feature
  processing_progress?: {
    message: string           // "Analyzing clips..."
    percentage: number        // 45
  }
}
```

---

## üé® How Frontend Uses This Data

### 1. **VideoPlayer Component**

```typescript
// Expects:
game.video_url              // ‚úÖ Required - video source
game.hls_url                // ‚ö†Ô∏è Optional - HLS if available
game.title                  // ‚úÖ Required - display name

// Team colors (CRITICAL):
game.metadata.teams.home_team.name          // ‚ùå Currently missing
game.metadata.teams.home_team.jersey_color  // ‚ùå Currently missing
game.metadata.teams.away_team.name          // ‚ùå Currently missing
game.metadata.teams.away_team.jersey_color  // ‚ùå Currently missing

// Falls back to:
homeTeam = { name: 'Home', jersey_color: '#000000' }  // Black
awayTeam = { name: 'Away', jersey_color: '#FFFFFF' }  // White
```

**Color Mapping:**
```typescript
const colorMap = {
  'green': '#22C55E',
  'blue': '#3B82F6',
  'red': '#DC2626',
  'white': '#FFFFFF',
  'black': '#000000',
  'yellow': '#EAB308',
  'orange': '#F97316',
  'purple': '#A855F7',
  'navy': '#1E40AF',
}
// Or pass hex directly: "#016F32"
```

### 2. **Event Transformer** (Frontend Mapping Logic)

```typescript
// Input: game.events (from database - DIRECT ARRAY)
const dbEvents = game.events  // Array<{id, time, team, action, outcome, metadata}>

// Transform each event:
dbEvents.map(e => {
  // CRITICAL MAPPING LOGIC:
  let eventType = e.action.toLowerCase()  // "shot" | "kickout" | "turnover" | "foul"
  
  // For shots, use OUTCOME as type (not action)
  if (e.action === 'Shot' && e.outcome) {
    const outcome = e.outcome.toLowerCase()
    if (outcome === 'point') eventType = 'point'
    else if (outcome === 'wide') eventType = 'wide'
    else if (outcome === 'goal') eventType = 'goal'
    else if (outcome === 'saved') eventType = 'saved'
  }
  
  return {
    id: e.id,                      // "event_001"
    type: eventType,               // "point" | "wide" | "goal" | "kickout" | "turnover" | "foul"
    timestamp: e.time,             // Map 'time' ‚Üí 'timestamp'
    team: e.team,                  // "home" | "away"
    description: `${e.action} - ${e.outcome}`,  // "Shot - Point"
    metadata: {
      ...e.metadata,
      action: e.action,            // Preserve original "Shot"
      outcome: e.outcome,          // Preserve original "Point"
      scoreType: e.metadata?.scoreType || (e.outcome === 'Point' ? 'point' : undefined)
    }
  }
})

// WHY THIS MAPPING?
// - Database: action="Shot", outcome="Point"
// - UI filters expect: type="point" (not type="shot")
// - This allows "Point" filter to work correctly
```

### 3. **Timeline Display**

Uses `game.metadata.teams` to color the timeline:
- Home events ‚Üí `game.metadata.teams.home_team.jersey_color`
- Away events ‚Üí `game.metadata.teams.away_team.jersey_color`

Without this data:
- ‚ùå Timeline shows all events as black/white
- ‚ùå No visual distinction between teams
- ‚ùå Looks boring/confusing

### 4. **Score Calculator**

```typescript
calculateScore(events)
// Counts events where:
// - action === 'Shot'
// - outcome === 'Point' or 'Goal'
// Returns:
{
  home: { goals: 2, points: 15, display: "2-15" },
  away: { goals: 1, points: 12, display: "1-12" }
}
```

### 5. **Game Stats** (UPDATED Nov 19)

Stats component needs to check for ALL shot-related types:

```typescript
// CORRECT: Check for all shot types
const homeShots = homeEvents.filter(e => 
  e.type === 'shot' || 
  e.type === 'point' || 
  e.type === 'wide' || 
  e.type === 'goal' || 
  e.type === 'saved' ||
  e.metadata?.action === 'Shot'  // Fallback
)

const homePoints = homeShots.filter(e => 
  e.type === 'point' || 
  e.metadata?.scoreType === 'point'
).length

const homeWides = homeShots.filter(e => 
  e.type === 'wide' || 
  e.metadata?.scoreType === 'wide'
).length
```

**Aggregates:**
- Shot accuracy (shots vs points/goals)
- Kickout success rate
- Turnover stats  
- Foul counts
- Conversion rates
- Possession (based on event counts)

All grouped by `team` field.

---

## üöÄ Lambda Output (CURRENT IMPLEMENTATION)

### Lambda 2 Posts to: `POST /api/games/:id/events`

**Actual payload Lambda sends (as of Nov 19, 2025):**

```json
{
  "events": [
    {
      "id": "event_001",
      "time": 11,
      "team": "home",
      "action": "Shot",
      "outcome": "Point",
      "metadata": {
        "from": "play",
        "scoreType": "point"
      }
    },
    {
      "id": "event_002",
      "time": 40,
      "team": "away",
      "action": "Kickout",
      "outcome": "Lost"
    }
  ],
  
  "match_info": {
    "title": "GAA Match",
    "total_events": 42,
    "analysis_method": "Gemini AI - First 10 minutes",
    "created_at": null
  },
  
  "team_mapping": {
    "red": "home",
    "blue": "away"
  },
  
  "metadata": {
    "teams": {
      "home_team": {
        "name": "Home",
        "jersey_color": "Black"
      },
      "away_team": {
        "name": "Away",
        "jersey_color": "White"
      }
    }
  }
}
```

### Backend Storage (CURRENT)

**Backend processes and stores as:**

```javascript
// backend/routes/games.js - POST /:id/events
UPDATE games
SET 
  events = $1::jsonb,      // ‚Üê Direct array of events
  metadata = $2::jsonb,    // ‚Üê team_mapping, match_info, teams
  status = 'analyzed'
WHERE id = game_id

// $1 = events array directly (not nested)
// $2 = {team_mapping, match_info, teams, updated_at}
```

**Database columns:**
- `events`: JSONB **array** `[{id, time, team, action, outcome, metadata}, ...]`
- `metadata`: JSONB **object** `{teams, match_info, team_mapping, updated_at}`

---

## üî¥ Current Gaps (What Still Needs Fixing)

### 1. ‚úÖ FIXED: Events Structure
- **Was**: Nested object with events inside
- **Now**: Direct array (fixed Nov 19, 2025)
- **Status**: ‚úÖ Working

### 2. ‚úÖ FIXED: Stats Calculation
- **Was**: Only checking `type === 'shot'`
- **Now**: Checks all shot types (`point`, `wide`, `goal`, `saved`)
- **Status**: ‚úÖ Working - Stats show correct scores

### 3. ‚úÖ FIXED: Event Type Mapping
- **Was**: All events mapped to `type: 'shot'`
- **Now**: Maps `action + outcome` ‚Üí specific type (`point`, `wide`, `goal`)
- **Status**: ‚úÖ Working - Event filters work correctly

### 4. ‚ö†Ô∏è PARTIAL: Team Colors
- **Lambda DOES detect colors** (Stage 0.5)
- **Lambda DOES send them** in `metadata.teams`
- **Issue**: Colors are generic ("Black", "White") not user's team colors
- **Why**: User's team colors (from DB) not passed from Lambda 1 ‚Üí Lambda 2
- **Impact**: Timeline shows correct detected colors, but not user's club colors

### 5. ‚ùå MISSING: Opposition Info
- **Frontend collects**: Opposition club name + county
- **Backend stores**: Nothing (fields don't exist)
- **Database**: No `opposition_name` or `opposition_county` columns
- **Impact**: Opposition info is lost after form submission

---

## üîß Future Improvements (Not Critical)

### 1. Pass User's Team Colors Through Lambda Chain

**Current**: Lambda detects colors from video ("Black", "White")  
**Ideal**: Lambda uses user's defined club colors ("#000000", "#FFD700")

**Required Changes:**

#### A. Backend: Pass team colors when triggering Lambda 1
```javascript
// backend/routes/games.js - POST /
triggerVeoDownload(game.id, videoUrl, {
  team_colors: {
    primary: teamData.primary_color,
    secondary: teamData.secondary_color,
    team_name: teamData.team_name
  }
})
```

#### B. Lambda 1: Forward team colors to Lambda 2
```python
# lambda/veo-downloader/lambda_handler.py
invoke_lambda_2({
  'game_id': game_id,
  's3_key': s3_key,
  'title': title,
  'team_colors': event.get('team_colors')  # Forward from backend
})
```

#### C. Lambda 2: Use for home/away matching
```python
# lambda/gaa-ai-analyzer/lambda_handler_s3.py
# After detecting colors, match with user's colors to assign home/away
user_colors = event.get('team_colors', {})
if team_a_color matches user_colors['primary']:
    team_mapping = {'red': 'home', 'blue': 'away'}
else:
    team_mapping = {'red': 'away', 'blue': 'home'}
```

**Benefit**: Timeline would show actual club colors, not generic black/white

---

### 2. Store Opposition Information

**Add database columns:**
```sql
ALTER TABLE games
ADD COLUMN opposition_name VARCHAR(255),
ADD COLUMN opposition_county VARCHAR(100);
```

**Update backend:**
```javascript
// backend/routes/games.js - POST /
const { oppositionName, oppositionCounty } = req.body
INSERT INTO games (..., opposition_name, opposition_county)
VALUES (..., oppositionName, oppositionCounty)
```

**Update frontend:**
```javascript
// frontend UploadSection.tsx
await games.create({
  title,
  teamId,
  videoUrl,
  oppositionName: oppositionClub,
  oppositionCounty: oppositionCounty
})
```

**Benefit**: Can display "vs [Opposition]" and filter games by opponent

---

## üìã Testing Checklist

After implementing changes:

1. ‚úÖ Deploy updated Lambda 2
2. ‚úÖ Submit a test VEO URL
3. ‚úÖ Check Lambda CloudWatch logs for:
   - `team_a_color` and `team_b_color` detected
   - Parsed team names from title
   - POST payload includes `metadata.teams`
4. ‚úÖ Check database:
   ```sql
   SELECT 
     id, 
     title, 
     metadata->'teams' as teams,
     events->'team_mapping' as team_mapping
   FROM games 
   WHERE id = 'test-game-id';
   ```
5. ‚úÖ Check frontend display:
   - Timeline shows correct team colors
   - Event badges show team colors
   - No black/white fallback

---

## üéØ Summary (Current State - Nov 19, 2025)

### ‚úÖ What's Working

**Database Structure:**
- Events stored as **direct JSONB array** ‚úÖ
- Metadata stored separately with team info, team_mapping, match_info ‚úÖ
- Backend correctly extracts events from Lambda payload ‚úÖ

**Frontend Display:**
- Events tab shows all events correctly ‚úÖ
- Event type filters work (Point, Wide, Goal, Kickout, etc.) ‚úÖ
- Stats tab calculates scores correctly (HOME 0-04, AWAY 0-02) ‚úÖ
- Event transformer maps `action + outcome ‚Üí type` ‚úÖ

**Lambda Pipeline:**
- Detects team colors from video ‚úÖ
- Generates events with correct format ‚úÖ
- Posts to backend with metadata ‚úÖ
- Stores XML to S3 (for Anadi export) ‚úÖ

### ‚ö†Ô∏è Minor Improvements Available

**Team Colors:**
- Currently: AI-detected colors ("Black", "White")
- Ideal: User's defined club colors ("#000000", "#FFD700")
- **Impact**: Low - system works, just less personalized

**Opposition Info:**
- Currently: Lost after form submission
- Ideal: Stored in database for filtering/display
- **Impact**: Low - can see in title, just not searchable

### üìä Data Flow (Verified Working)

```
User submits game
  ‚Üì
Backend creates game (status: "pending")
  ‚Üì
Lambda 1 downloads video from VEO ‚Üí S3
  ‚Üì
Lambda 2 analyzes video with Gemini AI
  ‚Üì
Lambda 2 posts events + metadata to backend
  ‚Üì
Backend stores:
  - events: [{id, time, team, action, outcome, metadata}, ...]
  - metadata: {teams, match_info, team_mapping, updated_at}
  ‚Üì
Frontend fetches game
  ‚Üì
Frontend transforms events (action ‚Üí type mapping)
  ‚Üì
Displays in Stats/Events/Coach tabs ‚úÖ
```

**System Status:** üü¢ Fully Operational

