#!/usr/bin/env node
/**
 * Add Events from XML File to Game
 * 
 * Parses GAA XML file and adds events to game via database.
 * 
 * Usage:
 *   node scripts/add-events-from-xml.js <game-id> <path-to-xml-file>
 */

const fs = require('fs');
const path = require('path');
const { DOMParser } = require('xmldom');

// Load environment variables
const envPath = path.join(__dirname, '../backend/.env');
if (fs.existsSync(envPath)) {
  const envContent = fs.readFileSync(envPath, 'utf8');
  envContent.split('\n').forEach(line => {
    const [key, ...valueParts] = line.split('=');
    if (key && valueParts.length > 0) {
      const value = valueParts.join('=').trim();
      if (!process.env[key.trim()]) {
        process.env[key.trim()] = value.replace(/^["']|["']$/g, '');
      }
    }
  });
}

const { query } = require('../backend/utils/database');

function parseXMLToEvents(xmlPath) {
  try {
    console.log(`üìÇ Reading XML file: ${xmlPath}`);
    const xmlContent = fs.readFileSync(xmlPath, 'utf8');
    
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
    
    // Check for parsing errors
    const parserError = xmlDoc.getElementsByTagName('parsererror')[0];
    if (parserError) {
      throw new Error('Invalid XML format: ' + parserError.textContent);
    }
    
    const events = [];
    
    // Parse instance elements (VEO/iSportsAnalysis format)
    const instanceNodes = xmlDoc.getElementsByTagName('instance');
    
    console.log(`üìä Found ${instanceNodes.length} event instances in XML`);
    
    for (let i = 0; i < instanceNodes.length; i++) {
      const instance = instanceNodes[i];
      
      const idNode = instance.getElementsByTagName('ID')[0];
      const startNode = instance.getElementsByTagName('start')[0];
      const endNode = instance.getElementsByTagName('end')[0];
      const codeNode = instance.getElementsByTagName('code')[0];
      
      if (!idNode || !startNode || !codeNode) {
        console.warn(`‚ö†Ô∏è  Skipping incomplete event ${i + 1}`);
        continue;
      }
      
      const id = idNode.textContent;
      const startRaw = parseFloat(startNode.textContent);
      const endRaw = endNode ? parseFloat(endNode.textContent) : startRaw;
      const code = codeNode.textContent;
      
      // Convert from deciseconds to seconds
      const timeSeconds = Math.round(startRaw / 10);
      
      // Extract team from code (e.g., "Home Kick Off" -> team='home', action='Kick Off')
      let team = 'unknown';
      let baseAction = code;
      
      if (code.startsWith('Home ')) {
        team = 'home';
        baseAction = code.substring(5); // Remove "Home "
      } else if (code.startsWith('Opp ')) {
        team = 'away';
        baseAction = code.substring(4); // Remove "Opp "
      }
      
      // Extract additional info from labels
      const labelNodes = instance.getElementsByTagName('label');
      let outcome = 'N/A';
      let player = null;
      let description = code;
      
      for (let j = 0; j < labelNodes.length; j++) {
        const label = labelNodes[j];
        const groupAttr = label.getAttribute('group');
        const textNode = label.getElementsByTagName('text')[0];
        
        if (textNode) {
          const text = textNode.textContent;
          
          // Extract outcome from specific groups
          if (groupAttr === 'Shot Outcome' || groupAttr === 'Free Kick') {
            outcome = text;
          }
          
          // Use label text as description if available
          if (j === 0 && text) {
            description = text;
          }
        }
      }
      
      // Map VEO codes to GAA actions and outcomes
      const { action, finalOutcome, skip, metadata } = mapVeoCodeToGAA(baseAction, code, outcome);
      
      // Skip non-key events (possession changes, ball in/out of play, etc.)
      if (skip) {
        continue;
      }
      
      const event = {
        id: `event_${id}`,
        time: timeSeconds,
        team: team,
        action: action,
        outcome: finalOutcome,
        description: description,
        player: player,
        autoGenerated: false,
        validated: true,
        metadata: metadata || {},  // Add metadata for stats
        rawCode: code,
        rawStart: startRaw,
        rawEnd: endRaw
      };
      
      events.push(event);
    }
    
    console.log(`‚úÖ Parsed ${events.length} events from XML`);
    
    // Create GAA Events Schema format
    const eventsData = {
      match_info: {
        title: "GAA Match - XML Import",
        description: "Events imported from XML file",
        total_events: events.length,
        analysis_method: "XML Import",
        source_file: path.basename(xmlPath)
      },
      events: events
    };
    
    return eventsData;
  } catch (error) {
    console.error(`‚ùå Error parsing XML: ${error.message}`);
    throw error;
  }
}

function mapVeoCodeToGAA(baseAction, fullCode, labelOutcome) {
  // Events to SKIP (not important for stats)
  const skipEvents = [
    'Ball in Play',
    'Ball Out of Play',
    'Possession',  // Generic possession changes
    'Throw In',
    'Corner',
    'Cross',
    'A3 Entry',
    'Stats Pen',
    'Offside'
  ];
  
  // Check if this event should be skipped
  if (skipEvents.includes(baseAction)) {
    return { skip: true };
  }
  
  // Map IMPORTANT VEO actions to GAA actions, outcomes, and metadata
  
  // SHOTS - map VEO outcomes to scoreType
  if (baseAction === 'Shot at Goal') {
    const scoreTypeMap = {
      'On Target': 'point',  // Assume on target = point scored
      'Goal': 'goal',
      'Off Target': 'wide',
      'Save': 'saved',
      'Blocked': 'short_keeper'
    };
    
    return {
      action: 'Shot',
      finalOutcome: labelOutcome || 'N/A',
      skip: false,
      metadata: {
        scoreType: scoreTypeMap[labelOutcome] || 'other',
        from: 'play'
      }
    };
  }
  
  if (baseAction === 'Goal') {
    return {
      action: 'Shot',
      finalOutcome: 'Goal',
      skip: false,
      metadata: {
        scoreType: 'goal',
        from: 'play'
      }
    };
  }
  
  // KICKOUTS - Need to determine if won/lost from context
  // VEO doesn't explicitly say won/lost, so we'll assume kickouts are taken by the team
  if (baseAction === 'Kick Off' || baseAction === 'Goal Kick') {
    return {
      action: 'Kickout',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {
        possessionOutcome: 'won',  // Default assumption
        kickoutType: 'mid'  // Default
      }
    };
  }
  
  // TURNOVERS - "Regain Won" means team won turnover
  if (baseAction === 'Regain Won') {
    return {
      action: 'Turnover',
      finalOutcome: 'Won',
      skip: false,
      metadata: {
        turnoverType: 'forced'  // Regains are forced turnovers
      }
    };
  }
  
  // FOULS
  if (baseAction === 'Foul') {
    return {
      action: 'Foul',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {
        scorable: false  // Default, can't tell from VEO
      }
    };
  }
  
  if (baseAction === 'Free Kick') {
    // Free kick awarded - map to foul
    const isScorable = labelOutcome && (labelOutcome.includes('Direct') || labelOutcome.includes('Indirect'));
    return {
      action: 'Foul',
      finalOutcome: 'Awarded To',
      skip: false,
      metadata: {
        scorable: isScorable || false
      }
    };
  }
  
  // CARDS
  if (baseAction === 'Yellow Card') {
    return {
      action: 'Yellow Card',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {}
    };
  }
  
  if (baseAction === 'Red Card') {
    return {
      action: 'Red Card',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {}
    };
  }
  
  if (baseAction === 'Black Card') {
    return {
      action: 'Black Card',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {}
    };
  }
  
  // GAME FLOW
  if (baseAction === '1st Half Start' || baseAction === 'Half Time') {
    return {
      action: 'Half Time Whistle',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {}
    };
  }
  
  if (baseAction === '2nd Half End') {
    return {
      action: 'Full Time Whistle',
      finalOutcome: 'N/A',
      skip: false,
      metadata: {}
    };
  }
  
  // If not mapped and not in skip list, skip it anyway (conservative approach)
  return {
    action: baseAction,
    finalOutcome: labelOutcome || 'N/A',
    skip: true,
    metadata: {}
  };
}

async function updateGameEvents(gameId, eventsData) {
  try {
    console.log(`üì§ Updating game ${gameId} with ${eventsData.events.length} events...`);
    
    const result = await query(
      `UPDATE games 
       SET events = $1,
           status = 'analyzed',
           updated_at = NOW()
       WHERE id = $2
       RETURNING id, title, status`,
      [JSON.stringify(eventsData), gameId]
    );
    
    if (result.rows.length === 0) {
      throw new Error('Game not found');
    }
    
    const game = result.rows[0];
    console.log(`‚úÖ Successfully updated game: ${game.title}`);
    console.log(`   Status: ${game.status}`);
    console.log(`   Events count: ${eventsData.events.length}`);
    
    return true;
  } catch (error) {
    console.error(`‚ùå Database error: ${error.message}`);
    throw error;
  }
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    console.log('Usage:');
    console.log('  node scripts/add-events-from-xml.js <game-id> <path-to-xml-file>');
    console.log('\nExample:');
    console.log('  node scripts/add-events-from-xml.js b0c476bb-401a-4a10-9a42-ae6d2e72b0e6 ~/Downloads/veo-vid-mxl.xml');
    process.exit(1);
  }
  
  const gameId = args[0];
  const xmlPath = args[1];
  
  if (!fs.existsSync(xmlPath)) {
    console.error(`‚ùå XML file not found: ${xmlPath}`);
    process.exit(1);
  }
  
  try {
    const eventsData = parseXMLToEvents(xmlPath);
    await updateGameEvents(gameId, eventsData);
    
    console.log(`\n‚úÖ Done! Game has been populated with XML events.`);
    console.log(`\nView the game at: http://localhost:4011/games/${gameId}`);
    
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

main();

