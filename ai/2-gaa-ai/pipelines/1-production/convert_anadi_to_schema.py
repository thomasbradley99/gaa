#!/usr/bin/env python3
"""
Convert Anadi Pro XML to EVENT_SCHEMA.ts JSON format

Usage:
  python3 convert_anadi_to_schema.py --input ground_truth.xml --output events.json
"""

import argparse
import json
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Optional

def parse_anadi_code(code: str) -> tuple[str, str]:
    """
    Parse Anadi code format into action and team
    
    Examples:
      "Shot Own" -> ("Shot", "home")
      "Kickout Opp" -> ("Kickout", "away")
      "Turnover Won Own" -> ("Turnover", "home")
      "Foul Awarded Own" -> ("Foul", "home")
    """
    parts = code.split()
    
    # Extract team (Own = home, Opp = away)
    team = "home" if "Own" in parts else "away"
    
    # Extract action
    if "Shot" in code:
        action = "Shot"
    elif "Kickout" in code:
        action = "Kickout"
    elif "Turnover" in code:
        action = "Turnover"
    elif "Foul" in code:
        action = "Foul"
    elif "45m" in code:
        action = "45m"
    elif "Penalty" in code:
        action = "Penalty"
    elif "Throw" in code or "throw" in code.lower():
        action = "Throw-up"
    else:
        action = "Unknown"
    
    return action, team

def extract_labels(instance: ET.Element) -> Dict[str, str]:
    """Extract all label tags from instance"""
    labels = {}
    for label in instance.findall('label'):
        text_elem = label.find('text')
        if text_elem is not None and text_elem.text:
            label_text = text_elem.text.strip()
            labels[label_text.lower()] = label_text
    return labels

def determine_outcome(action: str, labels: Dict[str, str]) -> str:
    """Determine outcome based on action and labels"""
    
    if action == "Shot":
        if "point" in labels:
            return "Point"
        elif "wide" in labels:
            return "Wide"
        elif "goal" in labels:
            return "Goal"
        elif "saved" in labels:
            return "Saved"
        else:
            return "Point"  # Default for shots
    
    elif action in ["Kickout", "Throw-up"]:
        if "won" in labels:
            return "Won"
        elif "lost" in labels:
            return "Lost"
        else:
            return "Won"  # Default
    
    elif action == "Turnover":
        # Check if it's "Turnover Won Own" or "Turnover Lost Own"
        if "won" in labels or any("won" in l for l in labels.values()):
            return "Won"
        else:
            return "Lost"
    
    elif action == "Foul":
        if "awarded" in labels or any("awarded" in l for l in labels.values()):
            return "Awarded"
        else:
            return "Conceded"
    
    else:
        return "Unknown"

def extract_metadata(action: str, labels: Dict[str, str]) -> Dict:
    """Extract metadata based on action type and labels"""
    metadata = {
        "autoGenerated": False,  # From ground truth
        "validated": True         # Ground truth is validated
    }
    
    # Shot metadata
    if action == "Shot":
        if "from play" in labels:
            metadata["from"] = "play"
        elif "free" in labels or "from free" in labels:
            metadata["from"] = "free"
        elif "45m" in labels:
            metadata["from"] = "45m"
        elif "penalty" in labels:
            metadata["from"] = "penalty"
        
        # Score type
        if "point" in labels:
            metadata["scoreType"] = "point"
        elif "goal" in labels:
            metadata["scoreType"] = "goal"
        elif "wide" in labels:
            metadata["scoreType"] = "wide"
        elif "saved" in labels:
            metadata["scoreType"] = "saved"
    
    # Kickout metadata
    elif action == "Kickout":
        if "long" in labels:
            metadata["kickoutType"] = "long"
        elif "mid" in labels:
            metadata["kickoutType"] = "mid"
        elif "short" in labels:
            metadata["kickoutType"] = "short"
        
        if "left" in labels:
            metadata["direction"] = "left"
        elif "right" in labels:
            metadata["direction"] = "right"
        elif "centre" in labels or "center" in labels:
            metadata["direction"] = "centre"
    
    # Turnover metadata
    elif action == "Turnover":
        if "forced" in labels:
            metadata["turnoverType"] = "forced"
        elif "unforced" in labels:
            metadata["turnoverType"] = "unforced"
    
    # Foul metadata
    elif action == "Foul":
        if "scoreable" in labels:
            metadata["scoreable"] = True
    
    return metadata

def convert_anadi_xml_to_schema(xml_path: Path) -> List[Dict]:
    """Convert Anadi Pro XML to EVENT_SCHEMA format"""
    
    tree = ET.parse(xml_path)
    root = tree.getroot()
    
    events = []
    
    # Find all instances
    all_instances = root.find('ALL_INSTANCES')
    if all_instances is None:
        print("‚ö†Ô∏è  No ALL_INSTANCES found in XML")
        return events
    
    for instance in all_instances.findall('instance'):
        # Extract basic fields
        id_elem = instance.find('ID')
        start_elem = instance.find('start')
        code_elem = instance.find('code')
        
        if id_elem is None or start_elem is None or code_elem is None:
            continue
        
        event_id = f"event_{int(id_elem.text):03d}"
        time = float(start_elem.text)
        code = code_elem.text.strip()
        
        # Parse action and team
        action, team = parse_anadi_code(code)
        
        # Extract labels
        labels = extract_labels(instance)
        
        # Determine outcome
        outcome = determine_outcome(action, labels)
        
        # Extract metadata
        metadata = extract_metadata(action, labels)
        
        # Build event
        event = {
            "id": event_id,
            "time": round(time, 2),
            "team": team,
            "action": action,
            "outcome": outcome,
            "metadata": metadata
        }
        
        events.append(event)
    
    return events

def main():
    parser = argparse.ArgumentParser(description='Convert Anadi Pro XML to EVENT_SCHEMA JSON')
    parser.add_argument('--input', required=True, help='Input XML file (Anadi format)')
    parser.add_argument('--output', required=True, help='Output JSON file (EVENT_SCHEMA format)')
    parser.add_argument('--game', help='Game name (for finding input file)')
    args = parser.parse_args()
    
    # Resolve input path
    if args.game:
        input_path = Path(__file__).parent.parent.parent / "games" / args.game / "inputs" / args.input
    else:
        input_path = Path(args.input)
    
    if not input_path.exists():
        print(f"‚ùå Input file not found: {input_path}")
        return
    
    print(f"üìñ Reading Anadi XML: {input_path.name}")
    
    # Convert
    events = convert_anadi_xml_to_schema(input_path)
    
    print(f"‚úÖ Converted {len(events)} events")
    
    # Write output
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        json.dump(events, f, indent=2)
    
    print(f"üíæ Saved to: {output_path}")
    
    # Show sample
    if events:
        print(f"\nüìã Sample event:")
        print(json.dumps(events[0], indent=2))

if __name__ == '__main__':
    main()

