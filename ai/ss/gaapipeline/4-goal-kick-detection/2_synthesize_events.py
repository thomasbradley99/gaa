#!/usr/bin/env python3
"""
2_synthesize_events.py - Clean GAA Event Synthesis
Text descriptions ‚Üí Timeline JSON for webapp (GAA Events Schema)
"""

import json
import os
import re
from pathlib import Path
import google.generativeai as genai
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure Gemini
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set")
genai.configure(api_key=GEMINI_API_KEY)

def collect_analysis_results(analysis_dir):
    """Collect all analysis results from the directory"""
    results = []
    
    analysis_dir = Path(analysis_dir)
    if not analysis_dir.exists():
        print(f"‚ùå Analysis directory not found: {analysis_dir}")
        return results
    
    analysis_files = sorted(analysis_dir.glob("*.txt"))
    print(f"üìã Found {len(analysis_files)} analysis files")
    
    for file_path in analysis_files:
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Extract metadata from content
            timestamp_match = re.search(r'TIMESTAMP: (\d+:\d+)', content)
            clip_file_match = re.search(r'CLIP_FILE: (clip_\d+m\d+s\.mp4)', content)
            
            if timestamp_match and clip_file_match:
                timestamp = timestamp_match.group(1)
                minutes, seconds = map(int, timestamp.split(':'))
                clip_start_time = minutes * 60 + seconds
                
                results.append({
                    'file': file_path.name,
                    'half': 'first_half',
                    'clip_start_time': clip_start_time,
                    'timestamp': timestamp,
                    'clip_file': clip_file_match.group(1),
                    'content': content
                })
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error reading {file_path}: {e}")
    
    # Sort by time
    results.sort(key=lambda x: x['clip_start_time'])
    
    return results

def synthesize_events_with_ai(analysis_results):
    """Use Gemini 2.5 Pro to synthesize all analysis results into GAA Events Schema format"""
    
    # Prepare comprehensive prompt
    all_analyses = ""
    for result in analysis_results:
        all_analyses += f"\n--- {result['timestamp']} (starts at {result['clip_start_time']}s) ---\n"
        all_analyses += result['content']
        all_analyses += "\n"
    
    prompt = f"""
You are an expert GAA analyst synthesizing kickout data from {len(analysis_results)} clip analyses.

TASK: Create GAA Events Schema compliant JSON for webapp consumption.

ANALYSIS DATA:
{all_analyses}

REQUIRED OUTPUT FORMAT (GAA Events Schema):
{{
  "match_info": {{
    "title": "GAA Match - Kickout Events",
    "description": "AI-detected kickout events with exact timing",
    "total_events": [number],
    "analysis_method": "AI video analysis"
  }},
  "events": [
    {{
      "id": "kickout_1",
      "time": [absolute seconds from match start],
      "team": "red" or "blue",
      "action": "Kickout",
      "outcome": "Won" or "Lost" or "N/A",
      "autoGenerated": true,
      "validated": false
    }}
  ]
}}

SYNTHESIS REQUIREMENTS:
1. Only include confirmed kickouts (KICKOUT: YES with confidence ‚â•7)
2. Calculate absolute timing precisely (clip start time + exact contact time)
3. Map teams to "red" or "blue" based on jersey colors consistently
4. Set outcome based on possession result:
   - "Won" if kicking team retained possession
   - "Lost" if opposing team won possession  
   - "N/A" if contested/unclear
5. Generate unique IDs like "kickout_1", "kickout_2", etc.
6. All events should have autoGenerated: true, validated: false

TEAM MAPPING RULES:
- Analyze jersey colors across all clips
- Consistently map one team to "red" and other to "blue"
- Maintain this mapping throughout all events
- Base mapping on goalkeeper jersey colors mentioned

IMPORTANT:
- Use exact GAA Events Schema format
- Calculate precise timing
- Maintain team consistency
- Only include high-confidence kickouts (‚â•7)
- Set proper action/outcome combinations

Generate the complete JSON:
"""
    
    try:
        print(f"ü§ñ Sending {len(analysis_results)} analyses to Gemini 2.0 Flash...")
        print(f"üìù Prompt size: {len(prompt):,} characters")
        
        model = genai.GenerativeModel("gemini-2.0-flash")
        response = model.generate_content(prompt)
        
        print(f"‚úÖ AI synthesis complete! Response size: {len(response.text):,} characters")
        
        # Extract JSON from response
        json_match = re.search(r'\{.*\}', response.text, re.DOTALL)
        if json_match:
            json_text = json_match.group(0)
            return json.loads(json_text)
        else:
            print("‚ùå Could not extract JSON from AI response")
            print("Raw response:", response.text[:500] + "...")
            return None
            
    except Exception as e:
        print(f"‚ùå AI synthesis failed: {e}")
        return None

def validate_gaa_schema(event_data):
    """Validate the output against GAA Events Schema"""
    
    print("üîç Validating GAA Events Schema compliance...")
    
    errors = []
    
    # Check required top-level fields
    if 'match_info' not in event_data:
        errors.append("Missing 'match_info' field")
    if 'events' not in event_data:
        errors.append("Missing 'events' field")
    
    # Validate events
    if 'events' in event_data:
        for i, event in enumerate(event_data['events']):
            # Check required fields
            required_fields = ['id', 'time', 'team', 'action', 'outcome', 'autoGenerated', 'validated']
            for field in required_fields:
                if field not in event:
                    errors.append(f"Event {i}: Missing required field '{field}'")
            
            # Check field types and values
            if 'team' in event and event['team'] not in ['red', 'blue']:
                errors.append(f"Event {i}: Invalid team '{event['team']}' (must be 'red' or 'blue')")
            
            if 'action' in event and event['action'] != 'Kickout':
                errors.append(f"Event {i}: Invalid action '{event['action']}' (expected 'Kickout')")
            
            if 'outcome' in event and event['outcome'] not in ['Won', 'Lost', 'N/A']:
                errors.append(f"Event {i}: Invalid outcome '{event['outcome']}'")
            
            if 'time' in event and not isinstance(event['time'], (int, float)):
                errors.append(f"Event {i}: Time must be a number")
    
    if errors:
        print("‚ùå Schema validation errors:")
        for error in errors:
            print(f"   - {error}")
        return False
    else:
        print("‚úÖ Schema validation passed!")
        return True

def save_webapp_json(event_data, output_dir):
    """Save synthesis results for webapp consumption"""
    
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Validate schema first
    if not validate_gaa_schema(event_data):
        print("‚ö†Ô∏è  Schema validation failed, but saving anyway...")
    
    # Save main webapp JSON
    webapp_json = output_dir / "kickout_events.json"
    with open(webapp_json, 'w') as f:
        json.dump(event_data, f, indent=2)
    print(f"üíæ Webapp JSON saved: {webapp_json}")
    
    # Save summary text
    summary_file = output_dir / "analysis_summary.txt"
    with open(summary_file, 'w') as f:
        f.write("GAA KICKOUT EVENTS SUMMARY\n")
        f.write("=" * 40 + "\n\n")
        f.write(f"Total Events: {len(event_data.get('events', []))}\n")
        f.write(f"Schema: GAA Events Schema Compliant\n")
        f.write(f"Analysis Method: {event_data.get('match_info', {}).get('analysis_method', 'Unknown')}\n\n")
        
        # Count by team
        red_count = sum(1 for e in event_data.get('events', []) if e.get('team') == 'red')
        blue_count = sum(1 for e in event_data.get('events', []) if e.get('team') == 'blue')
        
        f.write(f"Events by Team:\n")
        f.write(f"  Red Team: {red_count}\n")
        f.write(f"  Blue Team: {blue_count}\n\n")
        
        # List events
        f.write("Event Timeline:\n")
        for event in event_data.get('events', []):
            time_str = f"{event['time']//60:02.0f}:{event['time']%60:02.0f}"
            f.write(f"  {time_str} - {event['team']} {event['action']} ({event['outcome']})\n")
    
    print(f"üìÑ Summary saved: {summary_file}")
    
    return webapp_json

def main():
    print("ü•Ö GAA KICKOUT SYNTHESIS - STEP 2: TEXT ‚Üí GAA EVENTS SCHEMA")
    print("=" * 60)
    
    # Setup paths
    analysis_dir = Path("results/kickout_analysis")
    output_dir = Path("results/webapp_output")
    
    # Collect analysis results
    print("üìã Collecting analysis results...")
    analysis_results = collect_analysis_results(analysis_dir)
    
    if not analysis_results:
        print("‚ùå No analysis results found!")
        print(f"   Make sure to run '1_analyze_clips.py' first")
        return
    
    print(f"‚úÖ Found {len(analysis_results)} analysis files")
    
    # Synthesize with AI
    print("ü§ñ Synthesizing events with Gemini 2.0 Flash...")
    event_data = synthesize_events_with_ai(analysis_results)
    
    if not event_data:
        print("‚ùå Synthesis failed!")
        return
    
    # Save results
    print("üíæ Saving GAA Events Schema JSON...")
    webapp_json = save_webapp_json(event_data, output_dir)
    
    print(f"\n‚úÖ SYNTHESIS COMPLETE!")
    print(f"üìÅ GAA Events JSON: {webapp_json}")
    print(f"üåê Ready to upload to your webapp!")
    
    # Show summary
    total_events = len(event_data.get('events', []))
    red_count = sum(1 for e in event_data.get('events', []) if e.get('team') == 'red')
    blue_count = sum(1 for e in event_data.get('events', []) if e.get('team') == 'blue')
    
    print(f"\nüìä SUMMARY:")
    print(f"   Total Events: {total_events}")
    print(f"   Red Team: {red_count}")
    print(f"   Blue Team: {blue_count}")
    print(f"   Schema: GAA Events Schema Compliant ‚úÖ")

if __name__ == "__main__":
    main() 