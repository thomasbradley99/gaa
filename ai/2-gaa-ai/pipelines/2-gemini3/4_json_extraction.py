#!/usr/bin/env python3
"""
Stage 4: Convert Text Events to EVENT_SCHEMA JSON

Parses text-format events from Stage 3 and converts to EVENT_SCHEMA JSON format
for use in evaluation, web viewer, and XML export.

Text Format (Stage 3 output):
  MM:SS - Event Code [Tag1] [Tag2]: Description

JSON Format (EVENT_SCHEMA output):
  {
    "id": "event_001",
    "time": 685.0,
    "team": "home" | "away",
    "action": "Shot" | "Kickout" | "Turnover" | "Foul" | "Throw-up",
    "outcome": "Point" | "Wide" | "Goal" | "Saved" | "Won" | "Lost" | "Awarded" | "Conceded",
    "metadata": { ... }
  }

Usage: python3 4_json_extraction.py --game {game-name}
"""

import json
import re
import argparse
from pathlib import Path
from typing import Dict, List, Optional

# Parse arguments
parser = argparse.ArgumentParser()
parser.add_argument('--game', required=True)
ARGS = parser.parse_args()

# Paths
PROD_ROOT = Path(__file__).parent.parent.parent
GAME_ROOT = PROD_ROOT / "games" / ARGS.game

# Auto-detect output folder from Stage 1
run_config = GAME_ROOT / "outputs" / ".current_run.txt"
if run_config.exists():
    output_folder = run_config.read_text().strip()
    print(f"ğŸ“ Using output folder: {output_folder}")
else:
    output_folder = "2-gemini3"
    print(f"ğŸ“ Using default folder: {output_folder}")

OUTPUT_DIR = GAME_ROOT / "outputs" / output_folder

def parse_event_line(line: str, event_id: int) -> Optional[Dict]:
    """
    Parse a single event line from Stage 3 into EVENT_SCHEMA format
    
    Input format: MM:SS - Event Code [Tag1] [Tag2]: Description
    Example: "17:15 - Shot Away [From Play] [Point]: Blue scores"
    
    Returns EVENT_SCHEMA dict or None if parsing fails
    """
    # Pattern: MM:SS - Event Code [optional tags]: Description
    match = re.match(r'(\d+):(\d+)\s*-\s*(.+)$', line)
    if not match:
        return None
    
    minutes, seconds, rest = match.groups()
    time = int(minutes) * 60 + int(seconds)
    
    # Extract event code (everything before first [ or :)
    code_match = re.match(r'([^\[\:]+)', rest)
    if not code_match:
        return None
    
    code = code_match.group(1).strip()
    
    # Extract all tags [tag1] [tag2] [tag3]
    tags = re.findall(r'\[([^\]]+)\]', rest)
    
    # Extract description (everything after last ] and :)
    desc_match = re.search(r'(?:\]\s*)?:\s*(.+)$', rest)
    description = desc_match.group(1).strip() if desc_match else code
    
    # Parse code into action, outcome, and team
    code_parts = code.split()
    
    # Determine action and extract team
    action = None
    team = None
    outcome = None
    
    if "Shot" in code:
        action = "Shot"
        team = "away" if "Away" in code else "home"
        # Outcome from tags
        for tag in tags:
            tag_lower = tag.lower()
            if tag_lower in ["point", "wide", "goal", "saved"]:
                outcome = tag.capitalize()
                break
        if not outcome:
            outcome = "Wide"  # Default
    
    elif "Kickout" in code:
        action = "Kickout"
        team = "away" if "Away" in code else "home"
        # Outcome from tags
        for tag in tags:
            if tag in ["Won", "Lost"]:
                outcome = tag
                break
        if not outcome:
            outcome = "Lost"  # Default
    
    elif "Turnover" in code:
        action = "Turnover"
        if "Won" in code:
            outcome = "Won"
            # Team that WON the turnover
            team = "away" if "Away" in code else "home"
        else:  # "Lost" in code
            outcome = "Lost"
            # Team that LOST the turnover
            team = "away" if "Away" in code else "home"
    
    elif "Foul" in code:
        action = "Foul"
        team = "away" if "Away" in code else "home"
        if "Awarded" in code:
            outcome = "Awarded"
        elif "Conceded" in code:
            outcome = "Conceded"
        else:
            outcome = "Conceded"  # Default
    
    elif "Throw" in code or "throw" in code.lower():
        action = "Throw-up"
        # Determine team from "Won Home" or "Won Away" tag
        for tag in tags:
            if "Won Home" in tag:
                team = "home"
                outcome = "Won"
            elif "Won Away" in tag:
                team = "away"
                outcome = "Won"
        if not team:
            team = "home"  # Default
        if not outcome:
            outcome = "Won"  # Default
    
    else:
        # Unknown event type, skip
        return None
    
    # Build metadata based on action type
    metadata = {"autoGenerated": True}
    
    if action == "Shot":
        # Extract "from" and "scoreType"
        for tag in tags:
            tag_lower = tag.lower()
            if "from play" in tag_lower:
                metadata["from"] = "play"
            elif "from free" in tag_lower:
                metadata["from"] = "free"
            elif "from 45m" in tag_lower:
                metadata["from"] = "45m"
            elif "from penalty" in tag_lower:
                metadata["from"] = "penalty"
            
            if "point" in tag_lower:
                metadata["scoreType"] = "point"
            elif "goal" in tag_lower:
                metadata["scoreType"] = "goal"
            elif "wide" in tag_lower:
                metadata["scoreType"] = "wide"
            elif "saved" in tag_lower or "save" in tag_lower:
                metadata["scoreType"] = "saved"
        
        # Ensure required fields
        if "from" not in metadata:
            metadata["from"] = "play"  # Default
        if "scoreType" not in metadata:
            metadata["scoreType"] = outcome.lower() if outcome else "wide"
    
    elif action == "Kickout":
        # Extract length, direction
        for tag in tags:
            tag_lower = tag.lower()
            if tag_lower in ["long", "mid", "short"]:
                metadata["kickoutType"] = tag_lower
            if tag_lower in ["left", "right", "centre", "center"]:
                metadata["direction"] = "centre" if tag_lower == "center" else tag_lower
    
    elif action == "Turnover":
        # Extract forced/unforced and zone
        for tag in tags:
            tag_lower = tag.lower()
            if tag_lower in ["forced", "unforced"]:
                metadata["turnoverType"] = tag_lower
            # Zone: D1, D2, D3, M1, M2, M3, A1, A2, A3
            if re.match(r'[DMA][1-3]', tag.upper()):
                metadata["zone"] = tag.upper()
    
    elif action == "Foul":
        # Extract scoreable flag
        for tag in tags:
            if tag.lower() == "scoreable":
                metadata["scoreable"] = True
    
    # Build event dict
    event = {
        "id": f"event_{event_id:03d}",
        "time": float(time),
        "team": team,
        "action": action,
        "outcome": outcome,
        "metadata": metadata
    }
    
    return event


def extract_json():
    """Extract structured JSON events from text narrative using regex parsing"""
    
    input_file = OUTPUT_DIR / "3_events_classified.txt"
    output_file = OUTPUT_DIR / "4_events.json"
    
    if not input_file.exists():
        raise FileNotFoundError(f"âŒ Input file not found: {input_file}")
    
    # Read classified events
    with open(input_file, 'r') as f:
        text_content = f.read()
    
    print(f"ğŸ“– Loaded text events: {len(text_content)} characters")
    
    events = []
    skipped_lines = []
    
    for line in text_content.split('\n'):
        line = line.strip()
        if not line or line.startswith('Here are') or line.startswith('**') or line.startswith('#'):
            continue
        
        # Try to parse the line
        event = parse_event_line(line, len(events) + 1)
        if event:
            events.append(event)
        else:
            # Only log if line looks like it should be an event (has timestamp)
            if re.match(r'\d+:\d+', line):
                skipped_lines.append(line[:80])  # Log first 80 chars
    
    if skipped_lines:
        print(f"\nâš ï¸  Skipped {len(skipped_lines)} lines (couldn't parse or non-detectable):")
        for skipped in skipped_lines[:5]:  # Show first 5
            print(f"   {skipped}")
        if len(skipped_lines) > 5:
            print(f"   ... and {len(skipped_lines) - 5} more")
    
    # Save JSON in EVENT_SCHEMA format
    with open(output_file, 'w') as f:
        json.dump(events, f, indent=2)
    
    print(f"\nâœ… Converted {len(events)} events to EVENT_SCHEMA format")
    print(f"ğŸ’¾ Saved to: {output_file}")
    
    # Show breakdown
    action_counts = {}
    for event in events:
        action = event['action']
        action_counts[action] = action_counts.get(action, 0) + 1
    
    print(f"\nğŸ“Š Event Breakdown:")
    for action, count in sorted(action_counts.items()):
        print(f"   {action}: {count}")
    
    return events


if __name__ == "__main__":
    print(f"ğŸ·ï¸  STAGE 4: TEXT â†’ EVENT_SCHEMA JSON CONVERSION")
    print(f"Game: {ARGS.game}")
    print("=" * 50)
    extract_json()
