#!/usr/bin/env python3
"""
Convert Anadi Pro XML to Web EVENT_SCHEMA JSON format

Transforms FULL Anadi Pro XML (with all possession, attack, stoppage data) 
into the webapp EVENT_SCHEMA.ts JSON format, filtering to only detectable events:
  - Shot
  - Kickout
  - Turnover
  - Foul

Usage:
  python3 anadi_to_web_schema.py --game kilmeena-vs-cill-chomain --input ground_truth_full_anadi.xml
  python3 anadi_to_web_schema.py --input ground_truth.xml --output web_schema.json
"""

import argparse
import json
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Optional

# Detectable events - only these will be converted to web schema
DETECTABLE_EVENTS = {"Shot", "Kickout", "Turnover", "Foul"}

def parse_anadi_code(code: str) -> tuple[str, str]:
    """
    Parse Anadi code format into action and team
    
    Examples:
      "Shot Own" -> ("Shot", "home")
      "Kickout Opp" -> ("Kickout", "away")
      "Turnover Won Own" -> ("Turnover", "home")
      "Foul Awarded Own" -> ("Foul", "home")
    """
    parts = code.split()
    
    # Extract team (Own = home, Opp = away)
    team = "home" if "Own" in parts else "away"
    
    # Extract action
    if "Shot" in code:
        action = "Shot"
    elif "Kickout" in code:
        action = "Kickout"
    elif "Turnover" in code:
        action = "Turnover"
    elif "Foul" in code:
        action = "Foul"
    elif "45m" in code:
        action = "45m"
    elif "Penalty" in code:
        action = "Penalty"
    elif "Throw" in code or "throw" in code.lower():
        action = "Throw-up"
    else:
        action = "Unknown"
    
    return action, team

def extract_labels(instance: ET.Element) -> Dict[str, str]:
    """Extract all label tags from instance"""
    labels = {}
    for label in instance.findall('label'):
        text_elem = label.find('text')
        if text_elem is not None and text_elem.text:
            label_text = text_elem.text.strip()
            labels[label_text.lower()] = label_text
    return labels

def determine_outcome(action: str, labels: Dict[str, str]) -> str:
    """Determine outcome based on action and labels"""
    
    if action == "Shot":
        if "point" in labels:
            return "Point"
        elif "wide" in labels:
            return "Wide"
        elif "goal" in labels:
            return "Goal"
        elif "saved" in labels:
            return "Saved"
        else:
            return "Point"  # Default for shots
    
    elif action in ["Kickout", "Throw-up"]:
        if "won" in labels:
            return "Won"
        elif "lost" in labels:
            return "Lost"
        else:
            return "Won"  # Default
    
    elif action == "Turnover":
        # Check if it's "Turnover Won Own" or "Turnover Lost Own"
        if "won" in labels or any("won" in l for l in labels.values()):
            return "Won"
        else:
            return "Lost"
    
    elif action == "Foul":
        if "awarded" in labels or any("awarded" in l for l in labels.values()):
            return "Awarded"
        else:
            return "Conceded"
    
    else:
        return "Unknown"

def extract_metadata(action: str, labels: Dict[str, str]) -> Dict:
    """Extract metadata based on action type and labels"""
    metadata = {
        "autoGenerated": False,  # From ground truth
        "validated": True         # Ground truth is validated
    }
    
    # Shot metadata
    if action == "Shot":
        if "from play" in labels:
            metadata["from"] = "play"
        elif "free" in labels or "from free" in labels:
            metadata["from"] = "free"
        elif "45m" in labels:
            metadata["from"] = "45m"
        elif "penalty" in labels:
            metadata["from"] = "penalty"
        
        # Score type
        if "point" in labels:
            metadata["scoreType"] = "point"
        elif "goal" in labels:
            metadata["scoreType"] = "goal"
        elif "wide" in labels:
            metadata["scoreType"] = "wide"
        elif "saved" in labels:
            metadata["scoreType"] = "saved"
    
    # Kickout metadata
    elif action == "Kickout":
        if "long" in labels:
            metadata["kickoutType"] = "long"
        elif "mid" in labels:
            metadata["kickoutType"] = "mid"
        elif "short" in labels:
            metadata["kickoutType"] = "short"
        
        if "left" in labels:
            metadata["direction"] = "left"
        elif "right" in labels:
            metadata["direction"] = "right"
        elif "centre" in labels or "center" in labels:
            metadata["direction"] = "centre"
    
    # Turnover metadata
    elif action == "Turnover":
        if "forced" in labels:
            metadata["turnoverType"] = "forced"
        elif "unforced" in labels:
            metadata["turnoverType"] = "unforced"
    
    # Foul metadata
    elif action == "Foul":
        if "scoreable" in labels:
            metadata["scoreable"] = True
    
    return metadata

def is_detectable_event(code: str) -> bool:
    """Check if the Anadi code represents a detectable event"""
    # Detectable event codes in Anadi format
    detectable_codes = [
        "Shot Own", "Shot Opp",
        "Kickout Own", "Kickout Opp",
        "Turnover Won", "Turnover lost",  # Note: Anadi uses lowercase 'lost'
        "Foul Awarded", "Foul Conceded",
        "Scoreable Foul Awarded", "Scoreable Foul Conceded"
    ]
    return code in detectable_codes

def convert_anadi_xml_to_schema(xml_path: Path) -> List[Dict]:
    """
    Convert FULL Anadi Pro XML to EVENT_SCHEMA format
    Filters to only detectable events (Shot, Kickout, Turnover, Foul)
    """
    
    tree = ET.parse(xml_path)
    root = tree.getroot()
    
    events = []
    skipped = 0
    
    # Find all instances
    all_instances = root.find('ALL_INSTANCES')
    if all_instances is None:
        print("âš ï¸  No ALL_INSTANCES found in XML")
        return events
    
    for instance in all_instances.findall('instance'):
        # Extract basic fields
        id_elem = instance.find('ID')
        start_elem = instance.find('start')
        code_elem = instance.find('code')
        
        if id_elem is None or start_elem is None or code_elem is None:
            continue
        
        code = code_elem.text.strip()
        
        # FILTER: Only process detectable events
        if not is_detectable_event(code):
            skipped += 1
            continue
        
        event_id = f"event_{int(id_elem.text):03d}"
        time = float(start_elem.text)
        
        # Parse action and team
        action, team = parse_anadi_code(code)
        
        # Extract labels
        labels = extract_labels(instance)
        
        # Determine outcome
        outcome = determine_outcome(action, labels)
        
        # Extract metadata
        metadata = extract_metadata(action, labels)
        
        # Build event
        event = {
            "id": event_id,
            "time": round(time, 2),
            "team": team,
            "action": action,
            "outcome": outcome,
            "metadata": metadata
        }
        
        events.append(event)
    
    if skipped > 0:
        print(f"   Filtered out {skipped} non-detectable events (Possession, Attack, Stoppage, etc.)")
    
    return events

def main():
    parser = argparse.ArgumentParser(description='Convert Anadi Pro XML to Web EVENT_SCHEMA JSON')
    parser.add_argument('--input', required=True, help='Input XML file (full Anadi Pro format)')
    parser.add_argument('--output', help='Output JSON file (Web EVENT_SCHEMA format). Default: inputs/web_schema.json')
    parser.add_argument('--game', help='Game name (for finding input file in games/{game}/inputs/)')
    parser.add_argument('--time-limit', type=float, help='Only include events up to this time in seconds (e.g., 600 for 10 min)')
    args = parser.parse_args()
    
    # Resolve input path
    if args.game:
        game_dir = Path(__file__).parent.parent.parent / "games" / args.game
        input_path = game_dir / "inputs" / args.input
        # Default output to game inputs directory
        if not args.output:
            output_path = game_dir / "inputs" / "web_schema.json"
        else:
            output_path = Path(args.output)
    else:
        input_path = Path(args.input)
        if not args.output:
            # Default output next to input file
            output_path = input_path.parent / "web_schema.json"
        else:
            output_path = Path(args.output)
    
    if not input_path.exists():
        print(f"âŒ Input file not found: {input_path}")
        return
    
    print(f"ğŸ“– Reading Anadi XML: {input_path.name}")
    
    # Convert
    events = convert_anadi_xml_to_schema(input_path)
    
    # Apply time filter if specified
    if args.time_limit:
        original_count = len(events)
        events = [e for e in events if e['time'] <= args.time_limit]
        filtered_count = original_count - len(events)
        print(f"â±ï¸  Time limit: {args.time_limit}s ({args.time_limit/60:.1f} min)")
        if filtered_count > 0:
            print(f"   Filtered out {filtered_count} events after time limit")
    
    if not events:
        print("âŒ No events found after filtering")
        return
    
    print(f"âœ… Converted {len(events)} events")
    print(f"   Time range: {events[0]['time']:.1f}s - {events[-1]['time']:.1f}s ({events[-1]['time']/60:.1f} min)")
    
    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        json.dump(events, f, indent=2)
    
    print(f"ğŸ’¾ Saved to: {output_path}")
    
    # Show sample
    if events:
        print(f"\nğŸ“‹ Sample events:")
        for event in events[:3]:
            print(f"  {event['time']:.1f}s: {event['team']} {event['action']} - {event['outcome']}")
    
    print(f"\nâœ… Ready for webapp EVENT_SCHEMA.ts format")

if __name__ == '__main__':
    main()

